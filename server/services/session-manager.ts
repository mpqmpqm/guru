import { v4 as uuidv4 } from "uuid";
import type { Response } from "express";

type AudioItem =
  | { type: "audio"; stream: AsyncIterable<Uint8Array>; onComplete: () => void }
  | { type: "silence"; durationMs: number; onComplete: () => void };

interface Session {
  id: string;
  createdAt: Date;
  audioQueue: AudioItem[];
  audioStreamActive: boolean;
  agentSessionId?: string;
  sseResponse?: Response;
  // Resolvers for when new audio is available
  audioReady: (() => void) | null;
  // Abort controller for cancelling the agent
  abortController: AbortController | null;
}

// Valid MP3 stereo silence frame at 44100Hz, 128kbps (~26ms per frame)
// Generated by ffmpeg: ffmpeg -f lavfi -i anullsrc=r=44100:cl=stereo -t 0.03 -b:a 128k -f mp3
// Frame size: 418 bytes (with padding bit set)
const SILENCE_FRAME = Buffer.from([
  0xff, 0xfb, 0x92, 0x64, 0x40, 0x8f, 0xf0, 0x00, 0x00, 0x69, 0x00, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x0d, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01,
  0xa4, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x34, 0x80, 0x00, 0x00, 0x04,
  // Remaining bytes are LAME-encoded silence (0x55 padding)
  ...new Array(418 - 36).fill(0x55),
]);

// Duration of one frame in ms (1152 samples at 44100Hz)
const FRAME_DURATION_MS = (1152 / 44100) * 1000; // ~26.12ms

function generateSilence(durationMs: number): Buffer {
  const framesNeeded = Math.ceil(durationMs / FRAME_DURATION_MS);
  const frames: Buffer[] = [];
  for (let i = 0; i < framesNeeded; i++) {
    frames.push(SILENCE_FRAME);
  }
  return Buffer.concat(frames);
}

class SessionManager {
  private sessions = new Map<string, Session>();

  createSession(): string {
    const id = uuidv4();
    this.sessions.set(id, {
      id,
      createdAt: new Date(),
      audioQueue: [],
      audioStreamActive: false,
      audioReady: null,
      abortController: null,
    });
    return id;
  }

  getSession(id: string): Session | undefined {
    return this.sessions.get(id);
  }

  setSSEResponse(sessionId: string, res: Response): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.sseResponse = res;
    }
  }

  setAgentSessionId(sessionId: string, agentSessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.agentSessionId = agentSessionId;
    }
  }

  setAbortController(sessionId: string, controller: AbortController): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.abortController = controller;
    }
  }

  abortAgent(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session?.abortController) {
      console.log(`Aborting agent for session ${sessionId}`);
      session.abortController.abort();
      session.abortController = null;
    }
  }

  queueAudio(sessionId: string, stream: AsyncIterable<Uint8Array>): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) return Promise.resolve();

    return new Promise((resolve) => {
      console.log(`[session] queueAudio for ${sessionId}, queue length: ${session.audioQueue.length + 1}`);
      session.audioQueue.push({ type: "audio", stream, onComplete: resolve });
      // Signal that new audio is available
      session.audioReady?.();
    });
  }

  queueSilence(sessionId: string, durationMs: number): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) return Promise.resolve();

    return new Promise((resolve) => {
      console.log(`[session] queueSilence for ${sessionId}: ${durationMs}ms`);
      session.audioQueue.push({ type: "silence", durationMs, onComplete: resolve });
      session.audioReady?.();
    });
  }

  // Send an SSE event to the client
  sendSSE(sessionId: string, event: string, data: unknown): void {
    const session = this.sessions.get(sessionId);
    if (!session?.sseResponse) return;

    session.sseResponse.write(`event: ${event}\n`);
    session.sseResponse.write(`data: ${JSON.stringify(data)}\n\n`);
  }

  // Async generator that yields audio chunks from the queue
  async *consumeAudioQueue(
    sessionId: string
  ): AsyncGenerator<{ type: "data"; data: Buffer } | { type: "flush" }> {
    const session = this.sessions.get(sessionId);
    if (!session) return;

    session.audioStreamActive = true;

    while (session.audioStreamActive) {
      // If queue is empty, wait for new audio
      if (session.audioQueue.length === 0) {
        await new Promise<void>((resolve) => {
          session.audioReady = resolve;
        });
        session.audioReady = null;
        continue;
      }

      const item = session.audioQueue.shift()!;

      if (item.type === "audio") {
        // Yield chunks from the audio stream
        let chunkCount = 0;
        let totalBytes = 0;
        for await (const chunk of item.stream) {
          chunkCount++;
          totalBytes += chunk.length;
          yield { type: "data" as const, data: Buffer.from(chunk) };
        }
        console.log(`[session] streamed audio: ${chunkCount} chunks, ${totalBytes} bytes`);
        // Signal flush and that this audio item is done
        yield { type: "flush" as const };
        item.onComplete();
      } else if (item.type === "silence") {
        // Generate and yield silence
        const silence = generateSilence(item.durationMs);
        console.log(`[session] generated ${item.durationMs}ms silence: ${silence.length} bytes`);
        yield { type: "data" as const, data: silence };
        yield { type: "flush" as const };
        item.onComplete();
      }
    }
  }

  closeAudioStream(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.audioStreamActive = false;
      session.audioReady?.();
    }
  }

  closeSession(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      this.closeAudioStream(sessionId);
      session.sseResponse?.end();
    }
    // Keep session for potential reconnection, clean up after 30 minutes
    setTimeout(
      () => {
        this.sessions.delete(sessionId);
      },
      30 * 60 * 1000
    );
  }
}

export const sessionManager = new SessionManager();

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>session | guru</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåÄ</text></svg>"
    />
    <link rel="stylesheet" href="/styles.css" />
    <style>
      body {
        overflow: auto;
      }

      .inspect-container {
        max-width: 720px;
        margin: 0 auto;
        padding: 2rem 1rem;
        min-height: 100dvh;
      }

      .inspect-header {
        margin-bottom: 2rem;
      }

      .inspect-header a {
        color: var(--text-secondary);
        text-decoration: none;
        font-size: 0.875rem;
        display: inline-block;
        margin-bottom: 1rem;
      }

      .inspect-header a:hover {
        color: var(--accent-amber);
      }

      .session-info {
        background: var(--bg-surface);
        border: 1px solid var(--border-subtle);
        border-radius: 8px;
        padding: 1.25rem;
        margin-bottom: 1.5rem;
      }

      .session-top-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 1rem;
        padding-bottom: 0.75rem;
        border-bottom: 1px solid var(--border-subtle);
      }

      .session-id {
        font-family: monospace;
        font-size: 0.6875rem;
        color: var(--text-secondary);
        opacity: 0.7;
      }

      .session-model {
        font-family: monospace;
        font-size: 0.6875rem;
        color: var(--text-secondary);
      }

      .session-status {
        margin-left: auto;
        padding: 0.25rem 0.625rem;
        border-radius: 4px;
        font-size: 0.6875rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        font-weight: 500;
      }

      .session-status.completed {
        background: rgba(107, 143, 113, 0.2);
        color: var(--accent-success);
      }

      .session-status.active {
        background: rgba(212, 168, 83, 0.2);
        color: var(--accent-amber);
      }

      .session-status.closed {
        background: rgba(199, 95, 95, 0.2);
        color: var(--accent-error);
      }

      .session-prompt {
        color: var(--text-primary);
        font-size: 0.875rem;
        line-height: 1.25;
        margin-bottom: 1rem;
        white-space: pre-wrap;
      }

      .session-meta {
        color: var(--text-secondary);
        font-size: 0.8125rem;
        margin-bottom: 1rem;
      }

      .session-costs {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1rem;
        padding: 0.75rem;
        background: var(--bg-deep);
        border-radius: 6px;
        font-size: 0.8125rem;
      }

      .cost-item {
        display: flex;
        flex-direction: column;
        gap: 0.125rem;
      }

      .cost-label {
        color: var(--text-secondary);
        font-size: 0.6875rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .cost-value {
        color: var(--text-primary);
        font-family: monospace;
      }

      .cost-value.pending {
        color: var(--accent-amber);
      }

      .session-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .export-section {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--border-subtle);
      }

      .timeline {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .event {
        border-radius: 8px;
        overflow: hidden;
      }

      .event-thinking {
        background: var(--bg-surface);
        border: 1px solid var(--border-subtle);
      }

      .event-thinking summary {
        padding: 0.75rem 1rem;
        cursor: pointer;
        color: var(--text-secondary);
        font-size: 0.8125rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .event-thinking summary:hover {
        color: var(--text-primary);
      }

      .event-thinking[open] summary {
        border-bottom: 1px solid var(--border-subtle);
      }

      .event-thinking pre {
        margin: 0;
        padding: 1rem;
        font-size: 0.8125rem;
        line-height: 1.5;
        color: var(--text-secondary);
        white-space: pre-wrap;
        word-break: break-word;
        max-height: 400px;
        overflow-y: auto;
      }

      .event-cue {
        background: var(--bg-elevated);
        border: 1px solid var(--accent-amber);
        border-left-width: 3px;
        padding: 1rem;
      }

      .event-silence {
        background: var(--bg-surface);
        border: 1px solid var(--border-subtle);
        border-left: 3px solid var(--text-secondary);
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .silence-label {
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--text-secondary);
      }

      .silence-duration {
        font-family: monospace;
        color: var(--text-secondary);
      }

      .event-error {
        background: rgba(199, 95, 95, 0.1);
        border: 1px solid var(--accent-error);
        border-left-width: 3px;
        padding: 0.75rem 1rem;
        display: flex;
        align-items: flex-start;
        gap: 0.75rem;
      }

      .error-label {
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--accent-error);
      }

      .error-source {
        font-family: monospace;
        font-size: 0.75rem;
        color: var(--text-secondary);
      }

      .error-message {
        color: var(--text-secondary);
        font-size: 0.875rem;
      }

      .cue-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }

      .cue-label {
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--accent-amber);
      }

      .cue-seq {
        font-size: 0.6875rem;
        color: var(--text-secondary);
        font-family: monospace;
      }

      .cue-text {
        color: var(--text-primary);
        font-size: 1.0625rem;
        line-height: 1.5;
        margin-bottom: 0.75rem;
      }

      .cue-details {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        font-size: 0.8125rem;
        color: var(--text-secondary);
      }

      .cue-detail {
        display: flex;
        gap: 0.375rem;
      }

      .cue-detail-label {
        opacity: 0.7;
      }

      .cue-footer {
        margin-top: 0.75rem;
        padding-top: 0.5rem;
        border-top: 1px solid var(--border-subtle);
        font-size: 0.75rem;
        font-family: monospace;
        color: var(--text-secondary);
        opacity: 0.7;
      }

      .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        color: var(--text-secondary);
      }

      .loading {
        text-align: center;
        padding: 3rem 1rem;
        color: var(--text-secondary);
      }

      .delete-btn {
        background: transparent;
        border: 1px solid var(--accent-error);
        color: var(--accent-error);
        padding: 0.375rem 0.75rem;
        border-radius: 6px;
        font-size: 0.8125rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .delete-btn:hover {
        background: var(--accent-error);
        color: var(--bg-deep);
      }

      .cancel-export-btn {
        background: transparent;
        border: 1px solid var(--text-secondary);
        color: var(--text-secondary);
        padding: 0.375rem 0.75rem;
        border-radius: 6px;
        font-size: 0.8125rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .cancel-export-btn:hover {
        border-color: var(--accent-error);
        color: var(--accent-error);
      }

      .copy-btn {
        background: transparent;
        border: 1px solid var(--text-secondary);
        color: var(--text-secondary);
        padding: 0.375rem 0.75rem;
        border-radius: 6px;
        font-size: 0.8125rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .copy-btn:hover {
        border-color: var(--accent-amber);
        color: var(--accent-amber);
      }

      .copy-btn.copied {
        border-color: var(--accent-success);
        color: var(--accent-success);
      }

      .replay-row {
        margin: 1.25rem 0;
      }

      .replay-btn {
        background: var(--accent-amber);
        border: 1px solid var(--accent-amber);
        color: var(--bg-deep);
        padding: 0.625rem 1.5rem;
        border-radius: 6px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 100%;
      }

      .replay-btn:hover {
        background: transparent;
        color: var(--accent-amber);
      }

      .export-btn {
        background: transparent;
        border: 1px solid var(--text-secondary);
        color: var(--text-secondary);
        padding: 0.375rem 0.75rem;
        border-radius: 6px;
        font-size: 0.8125rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .export-btn:hover:not(:disabled) {
        border-color: var(--accent-amber);
        color: var(--accent-amber);
      }

      .export-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .export-btn.exporting {
        border-color: var(--accent-amber);
        color: var(--accent-amber);
      }

      .export-btn.complete {
        border-color: var(--accent-error);
        color: var(--accent-error);
      }

      .export-btn.error {
        border-color: var(--accent-error);
        color: var(--accent-error);
      }

      .export-status {
        font-size: 0.75rem;
        color: var(--text-secondary);
      }

      .export-status:not(:empty) {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--border-subtle);
      }

      .export-link {
        color: var(--accent-success);
        text-decoration: none;
        font-size: 0.8125rem;
      }

      .export-link:hover {
        text-decoration: underline;
      }

      .seq-badge {
        font-family: monospace;
        font-size: 0.6875rem;
        color: var(--text-secondary);
        background: var(--bg-deep);
        padding: 0.125rem 0.375rem;
        border-radius: 4px;
      }

      .queue-badge {
        font-family: monospace;
        font-size: 0.625rem;
        color: var(--accent-amber);
        background: rgba(212, 168, 83, 0.15);
        padding: 0.125rem 0.375rem;
        border-radius: 4px;
      }

      .event-tool {
        background: var(--bg-surface);
        border: 1px solid var(--border-subtle);
        border-left: 3px solid #8b7ec8;
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .tool-label {
        font-size: 0.6875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: #8b7ec8;
      }

      .tool-name {
        font-family: monospace;
        color: var(--text-secondary);
      }

      .tool-result {
        color: var(--text-secondary);
        font-size: 0.875rem;
        flex-basis: 100%;
        margin-top: 0.25rem;
      }

      .event-meta {
        font-size: 0.75rem;
        color: var(--text-secondary);
        opacity: 0.7;
        font-family: monospace;
      }

      #token-chart {
        width: 100%;
        margin-top: 0.75rem;
        display: flex;
        gap: 1rem;
      }
      .chart-container {
        flex: 1;
        min-width: 0;
      }
      .chart-container svg {
        width: 100%;
        height: 120px;
      }
      @media (max-width: 600px) {
        #token-chart {
          flex-direction: column;
        }
      }
      .chart-title {
        font-size: 0.625rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 0.25rem;
      }
      .chart-line {
        fill: none;
        stroke-width: 1.5;
      }
      .line-cache-read {
        stroke: #6b8f71;
      }
      .line-cache-write {
        stroke: #d4a853;
      }
    </style>
  </head>
  <body>
    <div class="inspect-container">
      <div class="inspect-header">
        <a href="/inspect">‚Üê back to sessions</a>
        <div id="session-info" class="session-info">
          <div class="loading">Loading session...</div>
        </div>
      </div>

      <div id="timeline" class="timeline"></div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
      const sessionId = window.location.pathname
        .split("/")
        .pop();

      function renderTokenChart(messages) {
        if (!messages?.length) return;

        const container = document.getElementById("token-chart");
        const height = 120;
        const margin = {
          top: 5,
          right: 10,
          bottom: 20,
          left: 45,
        };

        // Compute cumulative sums with elapsed time
        const startTime = new Date(
          messages[0].created_at
        ).getTime();
        let cumRead = 0,
          cumWrite = 0;
        const data = messages.map((m) => ({
          time:
            (new Date(m.created_at).getTime() - startTime) /
            1000,
          cacheRead: (cumRead += m.cache_read_tokens),
          cacheWrite: (cumWrite += m.cache_creation_tokens),
        }));

        const maxTime = d3.max(data, (d) => d.time);

        const series = [
          {
            key: "cacheRead",
            title: "Cache Read",
            cls: "line-cache-read",
          },
          {
            key: "cacheWrite",
            title: "Cache Write",
            cls: "line-cache-write",
          },
        ];

        // Calculate width - check if stacked (column) or side-by-side
        const containerWidth = container.clientWidth;
        const isStacked = window.innerWidth <= 600;
        const chartWidth = isStacked
          ? containerWidth
          : (containerWidth - 16) / 2;

        series.forEach((s) => {
          const wrapper = document.createElement("div");
          wrapper.className = "chart-container";
          wrapper.innerHTML = `<div class="chart-title">${s.title}</div>`;
          container.appendChild(wrapper);

          const width = chartWidth;

          const x = d3
            .scaleLinear()
            .domain([0, maxTime])
            .range([margin.left, width - margin.right]);

          const y = d3
            .scaleLinear()
            .domain([0, d3.max(data, (d) => d[s.key])])
            .range([height - margin.bottom, margin.top]);

          const svg = d3
            .select(wrapper)
            .append("svg")
            .attr("viewBox", `0 0 ${width} ${height}`);

          svg
            .append("g")
            .attr(
              "transform",
              `translate(0,${height - margin.bottom})`
            )
            .call(
              d3
                .axisBottom(x)
                .ticks(3)
                .tickFormat((d) => `${Math.floor(d)}s`)
            );

          svg
            .append("g")
            .attr("transform", `translate(${margin.left},0)`)
            .call(
              d3
                .axisLeft(y)
                .ticks(4)
                .tickFormat(d3.format(".2s"))
            );

          const line = d3
            .line()
            .x((d) => x(d.time))
            .y((d) => y(d[s.key]));

          svg
            .append("path")
            .datum(data)
            .attr("class", `chart-line ${s.cls}`)
            .attr("d", line);
        });
      }

      async function loadSession() {
        const infoContainer =
          document.getElementById("session-info");
        const timelineContainer =
          document.getElementById("timeline");

        try {
          const response = await fetch(
            `/api/inspect/sessions/${sessionId}`
          );
          if (!response.ok) {
            throw new Error("Session not found");
          }

          const { session, events, messages } =
            await response.json();

          // Render session info
          const date = new Date(session.created_at);
          const formatted = date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "2-digit",
          });

          // Format costs
          const formatCost = (val) =>
            val != null ? `$${val.toFixed(4)}` : "‚Äî";
          const formatTokens = (val) =>
            val != null ? val.toLocaleString() : "‚Äî";
          // Cost is provisional (amber) unless session completed successfully
          const agentCostClass =
            session.status === "completed" ? "" : "pending";
          const totalCost =
            (session.agent_cost_usd || 0) +
            (session.tts_cost_usd || 0);

          infoContainer.innerHTML = `
            <div class="session-top-row">
              <span class="session-id">${session.id}</span>
              ${session.model ? `<span class="session-model">${escapeHtml(session.model)}</span>` : ""}
              <span class="session-status ${session.status}">${session.status}</span>
            </div>
            <div class="session-prompt">${escapeHtml(session.initial_prompt || "(no prompt)")}</div>
            <div class="replay-row">
              <button class="replay-btn" id="replay-btn" onclick="replaySession()">Replay</button>
            </div>
            <div class="session-meta">${formatted}</div>
            <div class="session-costs">
              <div class="cost-item">
                <span class="cost-label">Agent</span>
                <span class="cost-value ${agentCostClass}">${formatCost(session.agent_cost_usd)}</span>
              </div>
              <div class="cost-item">
                <span class="cost-label">TTS</span>
                <span class="cost-value">${formatCost(session.tts_cost_usd)}</span>
              </div>
              <div class="cost-item">
                <span class="cost-label">Total</span>
                <span class="cost-value">${formatCost(totalCost)}</span>
              </div>
              <div class="cost-item">
                <span class="cost-label">Tokens (in/out)</span>
                <span class="cost-value">${formatTokens(session.input_tokens)} / ${formatTokens(session.output_tokens)}</span>
              </div>
              <div class="cost-item">
                <span class="cost-label">Cache (read/write)</span>
                <span class="cost-value">${formatTokens(session.cache_read_tokens)} / ${formatTokens(session.cache_creation_tokens)}</span>
              </div>
              <div id="token-chart"></div>
            </div>
            <div class="session-actions">
              <button class="copy-btn" id="copy-btn" onclick="copyToClipboard()">Copy</button>
              <button class="copy-btn" id="copy-cues-btn" onclick="copyCuesToClipboard()">Copy Cues</button>
              <button class="export-btn" id="export-btn" onclick="startExport()">Export MP3</button>
              <button class="cancel-export-btn" id="cancel-export-btn" onclick="cancelExport()" style="display:none;">Cancel</button>
              <button class="delete-btn" onclick="deleteSession()">Delete</button>
            </div>
            <div id="export-status" class="export-status"></div>
          `;

          // Update export UI based on current status
          updateExportUI(session);

          // Render token chart
          renderTokenChart(messages);

          // Store session and events for copy function
          window.sessionData = session;
          window.sessionEvents = events;

          // Render timeline
          if (events.length === 0) {
            timelineContainer.innerHTML =
              '<div class="empty-state">No events recorded</div>';
            return;
          }

          timelineContainer.innerHTML = events
            .map((event) => {
              if (event.type === "thinking") {
                const queueBadge =
                  event.queueDepth != null
                    ? `<span class="queue-badge">q${event.queueDepth}</span>`
                    : "";
                return `
                  <details class="event event-thinking" open>
                    <summary>
                      <span class="seq-badge">${event.sequence_num}</span>
                      ${queueBadge}
                      thinking
                    </summary>
                    <pre>${escapeHtml(event.content)}</pre>
                  </details>
                `;
              } else if (event.type === "silence") {
                const sinceSpeakStr =
                  event.sinceSpeakMs != null
                    ? ` (${(event.sinceSpeakMs / 1000).toFixed(1)}s since speak)`
                    : "";
                const metaStr = event.wallClock
                  ? `@ ${event.wallClock}`
                  : "";
                return `
                  <div class="event event-silence">
                    <span class="seq-badge">${event.sequence_num}</span>
                    <span class="silence-label">silence</span>
                    <span class="silence-duration">${(event.durationMs / 1000).toFixed(1)}s${sinceSpeakStr}</span>
                    ${metaStr ? `<span class="event-meta">${metaStr}</span>` : ""}
                  </div>
                `;
              } else if (event.type === "error") {
                return `
                  <div class="event event-error">
                    <span class="seq-badge">${event.sequence_num}</span>
                    <span class="error-label">error</span>
                    <span class="error-source">[${escapeHtml(event.source)}]</span>
                    <span class="error-message">${escapeHtml(event.message)}</span>
                  </div>
                `;
              } else if (event.type === "tool_call") {
                const toolDisplay =
                  event.toolName === "stopwatch"
                    ? `${event.toolName}:${event.intent}${event.stopwatchId ? ` "${event.stopwatchId}"` : ""}`
                    : event.toolName;
                return `
                  <div class="event event-tool">
                    <span class="seq-badge">${event.sequence_num}</span>
                    <span class="tool-label">tool</span>
                    <span class="tool-name">${escapeHtml(toolDisplay)}</span>
                    <div class="tool-result">${escapeHtml(event.result)}</div>
                  </div>
                `;
              } else {
                const footerParts = [];
                if (event.queueDepth != null)
                  footerParts.push(`q${event.queueDepth}`);
                if (event.speakingMs != null) {
                  footerParts.push(
                    `${(event.speakingMs / 1000).toFixed(1)}s`
                  );
                }
                if (event.ratio) footerParts.push(event.ratio);
                if (event.gapDriftMs != null) {
                  const sign = event.gapDriftMs >= 0 ? "+" : "";
                  footerParts.push(
                    `drift ${sign}${(event.gapDriftMs / 1000).toFixed(1)}s`
                  );
                }
                if (event.wallClock)
                  footerParts.push(`@ ${event.wallClock}`);
                const footerStr = footerParts.join(" ¬∑ ");
                return `
                  <div class="event event-cue">
                    <div class="cue-header">
                      <span class="cue-label">cue</span>
                      <span class="cue-seq">#${event.sequence_num}</span>
                    </div>
                    <div class="cue-text">${escapeHtml(event.text)}</div>
                    <div class="cue-details">
                      <div class="cue-detail">
                        <span class="cue-detail-label">voice:</span>
                        <span>${escapeHtml(event.voice)}</span>
                      </div>
                    </div>
                    ${footerStr ? `<div class="cue-footer">${footerStr}</div>` : ""}
                  </div>
                `;
              }
            })
            .join("");
        } catch (error) {
          infoContainer.innerHTML = `<div class="empty-state">Error: ${error.message}</div>`;
          timelineContainer.innerHTML = "";
        }
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      async function deleteSession() {
        if (!confirm("Delete this session?")) return;

        try {
          const response = await fetch(
            `/api/inspect/sessions/${sessionId}`,
            {
              method: "DELETE",
            }
          );
          if (response.ok) {
            window.location.href = "/inspect";
          } else {
            alert("Failed to delete session");
          }
        } catch (error) {
          alert("Error deleting session: " + error.message);
        }
      }

      function replaySession() {
        window.location.href = `/?replay=${sessionId}`;
      }

      async function copyToClipboard() {
        const session = window.sessionData;
        const events = window.sessionEvents || [];

        if (!session) {
          return;
        }

        const date = new Date(session.created_at);
        const dateFormatted = date.toLocaleDateString("en-US", {
          month: "short",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "2-digit",
          second: "2-digit",
        });

        const header = `[${dateFormatted}]\n${session.initial_prompt || "(no prompt)"}`;

        const eventsFormatted = events
          .map((e) => {
            if (e.type === "thinking") {
              return `[thinking]\n${e.content}`;
            } else if (e.type === "silence") {
              return `[silence ${(e.durationMs / 1000).toFixed(1)}s]`;
            } else if (e.type === "error") {
              return `[error:${e.source}] ${e.message}`;
            } else if (e.type === "tool_call") {
              return `[${e.toolName}${e.intent ? ":" + e.intent : ""}] ${e.result}`;
            } else {
              return `[${e.voice}]\n${e.text}`;
            }
          })
          .join("\n\n");

        const formatted =
          header +
          (events.length > 0 ? "\n\n" + eventsFormatted : "");

        await navigator.clipboard.writeText(formatted);

        const btn = document.getElementById("copy-btn");
        btn.textContent = "Copied";
        btn.classList.add("copied");
        setTimeout(() => {
          btn.textContent = "Copy";
          btn.classList.remove("copied");
        }, 2000);
      }

      async function copyCuesToClipboard() {
        const session = window.sessionData;
        const events = window.sessionEvents || [];

        const cues = events
          .filter((e) => e.type === "speak")
          .map((e) => `[${e.voice}]\n${e.text}`)
          .join("\n\n");

        if (!cues) {
          return;
        }

        const prompt = session?.initial_prompt || "(no prompt)";
        const formatted = `${prompt}\n\n***\n\n${cues}`;

        await navigator.clipboard.writeText(formatted);

        const btn = document.getElementById("copy-cues-btn");
        btn.textContent = "Copied";
        btn.classList.add("copied");
        setTimeout(() => {
          btn.textContent = "Copy Cues";
          btn.classList.remove("copied");
        }, 2000);
      }

      let exportPollInterval = null;

      async function startExport() {
        const btn = document.getElementById("export-btn");
        btn.disabled = true;

        try {
          const res = await fetch(
            `/api/inspect/sessions/${sessionId}/export`,
            { method: "POST" }
          );
          const data = await res.json();

          if (res.ok) {
            updateExportUI({ export_status: "pending" });
            startExportPolling();
          } else {
            alert(data.error || "Export failed");
            btn.disabled = false;
          }
        } catch (err) {
          alert("Export request failed: " + err.message);
          btn.disabled = false;
        }
      }

      function startExportPolling() {
        if (exportPollInterval) {
          clearInterval(exportPollInterval);
        }

        exportPollInterval = setInterval(async () => {
          try {
            const res = await fetch(
              `/api/inspect/sessions/${sessionId}`
            );
            const { session } = await res.json();
            updateExportUI(session);

            if (
              session.export_status === "complete" ||
              session.export_status === "error"
            ) {
              clearInterval(exportPollInterval);
              exportPollInterval = null;
            }
          } catch (err) {
            console.error("Poll failed:", err);
          }
        }, 2000);
      }

      async function cancelExport() {
        // Stop polling immediately
        if (exportPollInterval) {
          clearInterval(exportPollInterval);
          exportPollInterval = null;
        }

        try {
          const res = await fetch(
            `/api/inspect/sessions/${sessionId}/export/cancel`,
            { method: "POST" }
          );
          if (res.ok) {
            updateExportUI({ export_status: null });
          }
        } catch (err) {
          console.error("Cancel failed:", err);
        }
      }

      function updateExportUI(session) {
        const btn = document.getElementById("export-btn");
        const cancelBtn = document.getElementById(
          "cancel-export-btn"
        );
        const status = document.getElementById("export-status");

        if (!btn || !status || !cancelBtn) return;

        btn.classList.remove("exporting", "complete", "error");
        cancelBtn.style.display = "none";

        switch (session.export_status) {
          case "pending":
            btn.disabled = true;
            btn.classList.add("exporting");
            btn.textContent = "Starting...";
            cancelBtn.style.display = "inline-block";
            status.innerHTML = "";
            startExportPolling();
            break;
          case "processing":
            btn.disabled = true;
            btn.classList.add("exporting");
            let progressText = "Processing...";
            if (session.export_progress) {
              try {
                const progress = JSON.parse(
                  session.export_progress
                );
                if (progress.phase === "tts") {
                  progressText = `Generating (${progress.current}/${progress.total})`;
                } else if (progress.phase === "encoding") {
                  progressText = "Encoding...";
                } else if (progress.phase === "uploading") {
                  progressText = "Uploading...";
                }
              } catch (e) {}
            }
            btn.textContent = progressText;
            cancelBtn.style.display = "inline-block";
            status.innerHTML = "";
            startExportPolling();
            break;
          case "complete":
            btn.disabled = false;
            btn.classList.add("complete");
            btn.textContent = "Re-export";
            status.innerHTML = `<audio controls src="${session.export_url}" style="display:block; width:100%;"></audio>`;
            break;
          case "error":
            btn.disabled = false;
            btn.classList.add("error");
            btn.textContent = "Retry Export";
            status.innerHTML = `Error: ${escapeHtml(session.export_error || "Unknown error")}`;
            break;
          default:
            btn.disabled = false;
            btn.textContent = "Export MP3";
            status.innerHTML = "";
        }
      }

      loadSession();
    </script>
  </body>
</html>
